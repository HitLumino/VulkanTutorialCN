## 介绍

在接下来的几个章节中，我们将用本章节介绍的vertex buffer替换在vertex shader中硬编码的顶点数据。
从最简单的创建一个对CPU可见的缓冲（利用`memcpy`直接拷贝顶点数据到此buffer）。最后我们将会看到如何
使用`staging buffer`拷贝顶点数据到高性能的内存当中（以提高数据传输效率）。

## 顶点着色器

首先，在着色器代码去掉含有的顶点数据。顶点着色器使用`in`关键字从顶点缓冲区获取输入信息。


```glsl
#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(location = 0) in vec2 inPosition;
layout(location = 1) in vec3 inColor;

layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
```

`inPosition`和`inColor`变量代表*顶点属性*。它们是在顶点缓冲区中为每个顶点指定的属性，
就像我们使用两个数组为每个顶点手动指定位置和颜色一样。

就像一样`fragColor`，`layout(location = x)`为输入分配位置索引，我们以后可以使用位置索引来引用它们。
重要的是要知道某些类型（例如`dvec3` 64位向量）使用多个*slot*。这意味着之后的索引必须至少高2倍：


```glsl
layout(location = 0) in dvec3 inPosition;
layout(location = 2) in vec3 inColor;
```

你可以通过[OpenGL wiki](https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)) 查看更多有关布局限定词的信息。
> Notes：有关限定词的布局解释说明：

```glsl
struct OutData
{
  vec3 data1;
  dvec4 data2;
  float val[3];
};

layout(location = 0) out vec3 vals[4];    // 消耗 4 个位置
layout(location = 4) out OutData myOut;   // 消耗 6 个位置. dvec4 uses 2, and `val[3]` uses 3 total
layout(location = 10) out vec2 texCoord;  // 消耗 1 个位置
```
## 顶点数据

我们正在将顶点数据从着色器代码移动到C++代码，用数组表示。首先介绍GLM库，该库为我们提供了与线性代数相关的类型，
例如向量和矩阵。我们将使用这些类型来指定位置和颜色向量。


```c++
#include <glm/glm.hpp>
```

创建一个`Vertex`具有两个属性的新结构，我们将在其中的顶点着色器中使用它们：

```c++
struct Vertex {
    glm::vec2 pos;
    glm::vec3 color;
};
```

GLM很方便地为我们提供了与着色器语言中使用的向量类型完全匹配的C++类型。


```c++
const std::vector<Vertex> vertices = {
    {{0.0f, -0.5f}, {1.0f, 0.0f, 0.0f}},
    {{0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}},
    {{-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}}
};
```

现在，使用该`Vertex`结构指定一个顶点数据数组。我们使用的位置和颜色值与以前完全相同，但是现在它们被合并为一个顶点数组。
这称为*interleaving*顶点属性。


## 绑定描述

下一步是告诉Vulkan，一旦将这种数据格式上传到GPU内存后如何将其传递给顶点着色器。传达此信息需要两种类型的结构。

第一个结构是[VkVertexInputBindingDescription](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVertexInputBindingDescription.html) ，
我们将向`Vertex`添加一个成员函数，`Vertex`以使用正确的数据填充该成员函数。（注：为了方便`Vertex`拿到自身的`VkVertexInputBindingDescription`）



```c++
struct Vertex {
    glm::vec2 pos;
    glm::vec3 color;

    static VkVertexInputBindingDescription getBindingDescription() {
        VkVertexInputBindingDescription bindingDescription{};

        return bindingDescription;
    }
};
```

`顶点绑定`描述了整个顶点从内存中加载数据的速率。它指定数据条目之间的字节数，以及是否在每个顶点之后或在
每个实例之后移至下一个数据块。

```c++
VkVertexInputBindingDescription bindingDescription{};
bindingDescription.binding = 0;
bindingDescription.stride = sizeof(Vertex);
bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
```

我们所有的每个顶点数据都打包在一个数组中，因此我们将只具有一个`binding`。该`binding`参数指定绑定数组中绑定的索引。
该`stride`参数指定从一个数据块到下一个数据块的字节数（`sizeof(Vertex)`），并且该`inputRate`参数可以具有以下值之一：
* `VK_VERTEX_INPUT_RATE_VERTEX`: 每个顶点后移至下一个数据块
* `VK_VERTEX_INPUT_RATE_INSTANCE`: 每个实例后移至下一个数据块

此处我们不使用`instanced`渲染。

## 属性描述

描述如何处理顶点输入的第二种结构是 [VkVertexInputAttributeDescription](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVertexInputAttributeDescription.html) 。
我们将添加另一个辅助函数`Vertex`来填充这些结构。


```c++
#include <array>

...

static std::array<VkVertexInputAttributeDescription, 2> getAttributeDescriptions() {
    std::array<VkVertexInputAttributeDescription, 2> attributeDescriptions{};

    return attributeDescriptions;
}
```

如函数原型所示，将有两个这样的结构。`属性描述结构`描述了如何从源自`绑定描述`的大量顶点数据中提取顶点属性。
此处我们有两个属性，位置和颜色，因此我们需要两个`属性描述结构`。


```c++
attributeDescriptions[0].binding = 0;
attributeDescriptions[0].location = 0;
attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
attributeDescriptions[0].offset = offsetof(Vertex, pos);
```

该`binding`参数告诉Vulkan每个顶点数据来自哪个绑定。该`location`参数引用`location`顶点着色器中输入的指令。
对应顶点着色器中的输入`0`，`layout(location = 0) in dvec3 inPosition;`该位置属性具有两个32位浮点分量（`dvec3`）。

该`format`参数描述该属性的数据类型。有点令人困惑，这些格式是使用与颜色格式相同的枚举指定的。以下着色器类型和格式通常一起使用：

* `float`: `VK_FORMAT_R32_SFLOAT`
* `vec2`: `VK_FORMAT_R32G32_SFLOAT`
* `vec3`: `VK_FORMAT_R32G32B32_SFLOAT`
* `vec4`: `VK_FORMAT_R32G32B32A32_SFLOAT`

如您所见，您应该使用颜色通道数量与着色器数据类型中的组件数量相匹配的格式。允许使用比着色器中的组件数更多的通道，
但是它们将被静默丢弃。如果通道数少于组件数，则BGA组件将使用默认值(0, 0, 1)。
颜色类型（`SFLOAT`，`UINT`，`SINT`）和比特宽度也应与着色器输入的类型匹配。请参阅以下示例：

* `ivec2`: `VK_FORMAT_R32G32_SINT`, 由32位有符号整数组成的2分量向量
* `uvec4`: `VK_FORMAT_R32G32B32A32_UINT`, 一个由32位有符号整数组成的4分量向量
* `double`: `VK_FORMAT_R64_SFLOAT`, 双精度 (64位) 浮点数

该`format`参数隐式定义属性数据的字节大小，并且该`offset`参数指定自要读取的每个顶点数据开始以来的字节数。
当前`offset`值为位置属性（`pos`）`0`与该结构的开头之间的字节偏移量，使用`offsetof`宏自动计算的。

```c++
attributeDescriptions[1].binding = 0;
attributeDescriptions[1].location = 1;
attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
attributeDescriptions[1].offset = offsetof(Vertex, color);
```
颜色属性的描述方式几乎相同。

## 管线顶点输入

现在，我们需要建立图形管线来接收以这种格式的顶点数据，在`createGraphicsPipeline`中通过引用该结构。
找到该 `vertexInputInfo`结构设置其相应的成员以引用上面介绍的两个描述：
* bindingDescription 绑定描述
* attributeDescriptions 属性藐视

```c++
auto bindingDescription = Vertex::getBindingDescription();
auto attributeDescriptions = Vertex::getAttributeDescriptions();

vertexInputInfo.vertexBindingDescriptionCount = 1;
vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescriptions.size());
vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();
```

现在，管道已准备好接受`vertices`容器格式的顶点数据，并将其传递给我们的顶点着色器。
如果现在在启用验证层的情况下运行该程序，您会看到它抱怨没有绑定到该绑定的顶点缓冲区。
下一步是创建一个顶点缓冲区并将顶点数据移到该缓冲区，以便GPU能够访问它。

[C++ 代码](/code/17_vertex_input.cpp) /
[顶点着色器](/code/17_shader_vertexbuffer.vert) /
[片段着色器](/code/17_shader_vertexbuffer.frag)
